// Read output from dicer to find MCS

#include <algorithm>
#include <iostream>
#include <memory>
#include <optional>
#include <vector>

#include "google/protobuf/text_format.h"

#include "absl/container/flat_hash_map.h"

#include "Foundational/accumulator/accumulator.h"
#include "Foundational/cmdline/cmdline.h"
#include "Foundational/data_source/iwstring_data_source.h"
#include "Foundational/iwmisc/misc.h"
#include "Foundational/iwstring/absl_hash.h"
#include "Foundational/iwstring/iwstring.h"

#include "Molecule_Lib/aromatic.h"
#include "Molecule_Lib/atom_typing.h"
#include "Molecule_Lib/molecule.h"
#include "Molecule_Lib/smiles.h"

#ifdef BUILD_BAZEL
#include "Molecule_Tools/dicer_fragments.pb.h"
#else
#include "dicer_fragments.pb.h"
#endif

namespace dicer_mcs {

using std::cerr;

constexpr char kOpenSquareBracket = '[';
constexpr char kCloseSquareBracket = ']';

int
Usage(int rc) {
// clang-format off
#if defined(GIT_HASH) && defined(TODAY)
  cerr << __FILE__ << " compiled " << TODAY << " git hash " << GIT_HASH << '\n';
#else
  cerr << __FILE__ << " compiled " << __DATE__ << " " << __TIME__ << '\n';
#endif
  // clang-format on
  // clang-format off
  cerr << R"(Consumes textproto outputs from dicer and computes mcs.
The input molecules must have been generated by numbered_smiles.

numbered_smiles file.smi
# gennerates file_num.smi
# Run dicer. The only mandatory option is '-I inc=100`.
dicer -B bCCD3 -B nbamide -B brcb -B proto -k 2 -z i -c -g all -I inc=100 -M 16 -M maxnr=9 file_num.smi > frags.textproto
# Note that increasing the number of bonds broken '-k 2' to 3, may significaly
# increase the run-time, 10x or more depending...
# Then run this tool
dicer_mcs -m 2 -v frags.textproto

The following options are recognised.
 -m <natoms>            minimum size of a fragment. Stronly suggest something > 1.
 -P <atype>             atom type specification for single atom expansion - not implemented.
 -Y <fname>             write all pairwise MCS combinations. File can become very large!
 -v                     verbose output.
)";
  // clang-format on

  ::exit(rc);
}

class Options {
  private:
    int _verbose;

    int _min_atoms_in_fragment;

  public:
    Options();

    int Initialise(Command_Line& cl);

    int verbose() const {
      return _verbose;
    }

    int min_atoms_in_fragment() const {
      return _min_atoms_in_fragment;
    }
};

Options::Options() {
  _verbose = 0;
  _min_atoms_in_fragment = 0;
}

int
Options::Initialise(Command_Line& cl) {
  _verbose = cl.option_count('v');

  if (cl.option_present('m')) {
    if (! cl.value('m', _min_atoms_in_fragment) || _min_atoms_in_fragment < 1) {
      cerr << "The min fragment size (-m) option must be a whole +ve number\n";
      return 1;
    }

    if (_verbose) {
      cerr << "Will discard fragments with fewer than " << _min_atoms_in_fragment << " atoms\n";
    }
  }

  return 1;
}

// Forward declaration.
class Fragment;

// Once we have read all the molecules in a set, we need to determine
// where the various fragments are found.
class FragmentSummary {
  private:
    // For this fragment a list of the molecules that contain the fragment.
    int* _in_molecule;
    int _molecules_with_fragment;

    // This must be initialised by a caller.
    int _natoms;

  public:
    // The two args are the total number of molecules and the index of
    // the molecule in which this fragment was first found.
    FragmentSummary(int nmolecules, int findx);
    FragmentSummary(FragmentSummary&& rhs);
    FragmentSummary(FragmentSummary& rhs) = delete;
    ~FragmentSummary();

    void set_natoms(int s) {
      _natoms = s;
    }
    int natoms() const {
      return _natoms;
    }

    // The caller is telling us that our fragment has been found in
    // molecule number `s`.
    void found_in_molecule(int s) {
      _in_molecule[s] = 1;
      ++_molecules_with_fragment;
    }

    int molecules_with_fragment() const {
      return _molecules_with_fragment;
    }

    // Does the Fragment we are summarising exist in parent `i`.
    bool is_found_in_molecule(int i) const {
      return _in_molecule[i] > 0;
    }
};

FragmentSummary::FragmentSummary(int nmolecules, int findx) {
  _in_molecule = new_int(nmolecules);
  _molecules_with_fragment = 0;
  _natoms = 0;
  found_in_molecule(findx);
}

FragmentSummary::FragmentSummary(FragmentSummary&& rhs) {
  _in_molecule = rhs._in_molecule;
  rhs._in_molecule = nullptr;
  _molecules_with_fragment = rhs._molecules_with_fragment;
  _natoms = rhs._natoms;
}

FragmentSummary::~FragmentSummary() {
  if (_in_molecule != nullptr) {
    delete [] _in_molecule;
  }
}

// Molecules come in with isotopic labels. But we need to mark
// the attachment points, so we offset the starting isotope by this amount.
constexpr isotope_t kIsotopeOffset = 100;

class Fragment {
  private:
    Molecule _mol;
    IWString _usmi;

    // So we know how to size various arrays.
    int _atoms_in_parent;

    // The index of the our parent molecule in an array of parents.
    // We do not do anything with this.
    int _parent_id;

    // A mapping from every atom in `_mol` to an atom number in the parent molecule.
    int* _parent_atom;
    // The isotopic label placed on the parent atom. Same as the canonical ranking.
    isotope_t* _parent_isotope;

  public:
    Fragment();
    ~Fragment();

    int Build(const Molecule& parent, int* tmp, const dicer_data::DicerFragment& proto);

    int natoms() const {
      return _mol.natoms();
    }

    const IWString& usmi() const {
      return _usmi;
    }

    void set_parent_id(int s) {
      _parent_id = s;
    }
    int parent_id() const {
      return _parent_id;
    }

    // Atom `parent` must be our parent molecule.
    // Scan through _parent_atom and set the appropriate isotope in `parent`.
    void SetIsotopes(Molecule& parent) const;

    // Wrtie our atom count and the atom count as a fraction of atoms in parent
    void AtomsAndFraction(IWString_and_File_Descriptor& output) const;

    // Given that we are found in molecule `ndx`, update the information in `summary`.
    int UpdateStats(int ndx, FragmentSummary& summary);

    // Build a smarts.
    int BuildSmarts(IWString& smarts);

};

Fragment::Fragment() {
  _parent_atom = nullptr;
  _parent_isotope = nullptr;
  _parent_id = -1;
  _atoms_in_parent = 0;
}

Fragment::~Fragment() {
  if (_parent_atom != nullptr) {
    delete [] _parent_atom;
  }
  if (_parent_isotope != nullptr) {
    delete [] _parent_isotope;
  }
}

// We are dealing with molecules from dicer with `-I add=100`.
// If there is an atom from which multiple bond breaks have happened,
// we might get an isotope > 200. Truncate these to the > 100 range.
int
TruncateToRange(isotope_t& iso) {
  int rc = 0;
  while (iso >= 2 * kIsotopeOffset) {
    iso -= kIsotopeOffset;
    ++rc;
  }

  return rc;
}


int
Fragment::Build(const Molecule& parent, int* tmp, const dicer_data::DicerFragment& proto) {
  if (!_mol.build_from_smiles(proto.smi())) {
    cerr << "Fragment::Build:invalid smiles '" << proto.smi() << "'\n";
    return 0;
  }

  std::unique_ptr<isotope_t[]> isosave = _mol.GetIsotopes();

  const int matoms = _mol.natoms();

  Set_of_Atoms attachment_points;
  for (int i = 0; i < matoms; ++i) {
    isotope_t iso = _mol.isotope(i);

    if (iso < kIsotopeOffset) {
      continue;
    }

    if (TruncateToRange(iso)) {
      _mol.set_isotope(i, iso);
      isosave[i] = iso;
    }

    attachment_points << i;
  }

  _mol.transform_to_non_isotopic_form();
  // Re-label the attachment points.
  for (atom_number_t a : attachment_points) {
    _mol.set_isotope(a, 1);
  }

  // After removal of isotopes, compute the canonical rank.
  // Beware, this includes the isotopic labels applied above.
  // Probably OK...
  const int* canonical_rank = _mol.canonical_ranks();

  _atoms_in_parent = parent.natoms();

  _parent_atom = new int[matoms];
  _parent_isotope = new isotope_t[matoms];

  for (int i = 0; i < matoms; ++i) {
    isotope_t iso = isosave[i];
    if (iso >= kIsotopeOffset) {
      iso -= kIsotopeOffset;
    }

    atom_number_t p = parent.atom_with_isotope(iso);
    if (p == kInvalidAtomNumber) {
      cerr << "Fragment::Build:no parent atom with isotope " << iso << '\n';
      return 0;
    }

    // cerr << " atom " << i << " iso " << iso << " came from atom " << p << " in parent molecule\n";
    _parent_atom[i] = p;
    _parent_isotope[i] = canonical_rank[i];
  }

  _usmi = _mol.unique_smiles();

  return 1;
}

void
Fragment::SetIsotopes(Molecule& parent) const {
  const int matoms = _mol.natoms();

  // cerr << "Fragment::SetIsotopes:processing " << matoms << " atoms\n";
  for (int i = 0; i < matoms; ++i) {
    // cerr << " atom " << i << " in parent " << _parent_atom[i] << " iso " << _parent_isotope[i] << '\n';
    parent.set_isotope(_parent_atom[i], _parent_isotope[i]);
  }
}
    
void
Fragment::AtomsAndFraction(IWString_and_File_Descriptor& output) const {
  output << _mol.natoms() << ' ' << iwmisc::Fraction<float>(_mol.natoms(),
                _atoms_in_parent);
}

void
FormSmarts(Molecule& m, atom_number_t zatom, IWString& smt) {
  const Element* e = m.elementi(zatom);

  smt << kOpenSquareBracket;
  IWString asymbol;
  if (m.is_aromatic(zatom)) {
    smt << e->aromatic_symbol();
  } else {
    smt << e->symbol();
  }

  if (m.isotope(zatom)) {
    smt << "D>" << m.ncon(zatom);
  } else {
    smt << "D" << m.ncon(zatom);
  }

  smt << kCloseSquareBracket;
}

int
Fragment::BuildSmarts(IWString& smarts) {
  const int matoms = _mol.natoms();

  // The D directive in the smarts will be as a minimum.
  set_make_smarts_embedding(1);
  set_write_smiles_aromatic_bonds_as_colons(1);

  Smiles_Information smi_info(matoms);
  smi_info.allocate_user_specified_atomic_smarts();
  _mol.compute_aromaticity_if_needed();

  IWString smt;  // Scope here for efficiency
  for (int i = 0; i < matoms; ++i) {
    smt.resize_keep_storage(0);

    FormSmarts(_mol, i, smt);

    smi_info.set_user_specified_atomic_smarts(i, smt);
  }

  _mol.smiles(smi_info);

  smarts = smi_info.smiles();

  set_write_smiles_aromatic_bonds_as_colons(0);

  return 1;
}


struct ComparisonConditions {
  // Each molecule consists of a number of fragments.
  // We scan each list looking for fragments that match.
  // If we stop at the first match, that will be a fully connected MCS.
  // If we allow disconnected MCS to be found then we need to
  // continue looking for non-overlapping fragments.
  int allow_disconnected_matches = 1;

  char record_separator = '\n';

  Accumulator_Int<uint32_t> _acc_natoms_overlap;
  Accumulator<double> _acc_fraction_overlap;
};

class DicedMolecule {
  private:
    // The parent molecule. When read in it must have isotopic labels.

    Molecule _mol;

    // Across all our fragments, a mapping from unique smiles to 
    // fragment number.
    absl::flat_hash_map<IWString, int> _usmi;

    resizable_array_p<Fragment> _fragment;

    std::unique_ptr<uint32_t[]> _atype;

    // Private functions
    int CompareInner(DicedMolecule& rhs, const ComparisonConditions& cmp,
                IWString_and_File_Descriptor& output);
    int ProcessMatch(int lhs_frag_number, DicedMolecule& rhs,
                int rhs_frag_number,
                const ComparisonConditions& cmp,
                IWString_and_File_Descriptor& output);
    int TryExpansion(DicedMolecule& rhs,
                const ComparisonConditions& cmp,
                isotope_t& next_isotope_to_assign);
    atom_number_t UnmatchedAtom(atom_number_t zatom, const Bond* b1,
                             uint32_t atype) const;

  public:
    DicedMolecule();
    ~DicedMolecule();

    int Build(const Options& options, const dicer_data::DicedMolecule& proto);

    int size() const {
      return _fragment.number_elements();
    }

    const IWString& name() const {
      return _mol.name();
    }

    Molecule& mol() {
      return _mol;
    }

    // If _usmi contains `s`, return _usmi[s].
    std::optional<int> Contains(const IWString& s) const;

    const Fragment* FragmentForSmiles(const IWString& smi) const;

    int Compare(DicedMolecule& rhs, const ComparisonConditions& cmp,
                IWString_and_File_Descriptor& output);

    int AssignAtomTypes(Atom_Typing_Specification& ats);

    // Given that we are molecule number `ndx` update the information
    // in `frag_data`.
    int UpdateStats(int nmolecules, int ndx, absl::flat_hash_map<IWString, FragmentSummary>& frag_data);
};

DicedMolecule::DicedMolecule() {
}

DicedMolecule::~DicedMolecule() {
}

// Each atom in `m` must have an isotopic label, with one atom
// having a value of 0.
// Some atoms will have offset isotopic labels, so those must be
// brought back into the range.
bool
ProperIsotopicLabelling(Molecule& m, int* tmp) {
  // cerr << m.smiles() << " checking isotopes " << m.name() << " contains " << m.natoms() << " atoms\n";
  const int matoms = m.natoms();
  int rc = true;
  for (int i = 0; i < matoms; ++i) {
    isotope_t iso = m.isotope(i);
    TruncateToRange(iso);
    if (static_cast<int>(iso) >= matoms) {
      cerr << "ProperIsotopicLabelling:isotopic label out of range\n";
      rc = false;
    }
    tmp[iso] += 1;
  }

  if (! rc) {
    return rc;
  }

  // Each isotopic value must have been encountered once.
  // Could use all_of, but the loop seems simpler
  // std::all_of(tmp.get(), tmp.get() + matoms, [](int one) { return one == 1;});
  for (int i = 0; i < matoms; ++i) {
    if (tmp[i] != 1) {
      cerr << "isotope " << i << " not initialised, count " << tmp[i] << '\n';
      return false;
    }
  }

  return true;
}

int
DicedMolecule::Build(const Options& options, const dicer_data::DicedMolecule& proto) {
  if (! _mol.build_from_smiles(proto.smiles())) {
    cerr << "DicedMolecule::Build:bad smiles\n";
    cerr << proto.ShortDebugString() << '\n';
    return 0;
  }

  const int matoms = _mol.natoms();

  if (matoms < 2) {
    cerr << "DicedMolecule::Build:Only one atom in the molecule\n";
    return 0;
  }

  _mol.set_name(proto.name());

  std::unique_ptr<int[]> tmp = std::make_unique<int[]>(matoms);
  std::fill_n(tmp.get(), matoms, 0);

  // All atoms must have an isotopic label.
  if (! ProperIsotopicLabelling(_mol, tmp.get())) {
    cerr << "DicedMolecule::Build:improper isotopic labelling\n";
    cerr << _mol.smiles() << ' ' << proto.name() << '\n';
    return 0;
  }

  int number_fragments = proto.fragment_size();

  if (number_fragments == 0) {
    cerr << "DicedMolecule::Build:no fragments\n";
    cerr << proto.ShortDebugString() << '\n';
    return 1;
  }

  _fragment.reserve(number_fragments);

  // cerr << "Paremt molecule contains " << matoms << " atoms\n";

  for (int i = 0; i < number_fragments; ++i) {
    std::unique_ptr<Fragment> f = std::make_unique<Fragment>();

    if (! f->Build(_mol, tmp.get(), proto.fragment(i))) {
      cerr << "DicedMolecule::Build:invalid fragment\n";
      cerr << proto.fragment(i).ShortDebugString() << '\n';
      return 0;
    }
    
    if (options.min_atoms_in_fragment() > 0 &&
        f->natoms() < options.min_atoms_in_fragment()) {
      continue;
    }

    f->set_parent_id(i);

    _fragment << f.release();
  }

  number_fragments = _fragment.number_elements();

  // Sort by fragment size, largest first.
  std::sort(_fragment.rawdata(), _fragment.rawdata() + number_fragments, [](const Fragment* f1, const Fragment* f2) {
    return f1->natoms() > f2->natoms();
  });

  // Establish the cross reference from fragment unique smiles to index.
  for (int i = 0; i < number_fragments; ++i) {
    _usmi[_fragment[i]->usmi()] = i;
  }

  _mol.transform_to_non_isotopic_form();

  return 1;
}

std::optional<int>
DicedMolecule::Contains(const IWString& s) const {
  const auto iter = _usmi.find(s);
  if (iter == _usmi.end()) {
    return std::nullopt;
  }

  return iter->second;
}

const Fragment*
DicedMolecule::FragmentForSmiles(const IWString& smi) const {
  const auto iter = _usmi.find(smi);
  if (iter == _usmi.end()) {
    return nullptr;
  }
  
  return _fragment[iter->second];
}

int
DicedMolecule::AssignAtomTypes(Atom_Typing_Specification& ats) {
  _atype = std::make_unique<uint32_t[]>(_mol.natoms());
  return ats.assign_atom_types(_mol, _atype.get());
}

int
DicedMolecule::Compare(DicedMolecule& rhs, const ComparisonConditions& cmp,
                IWString_and_File_Descriptor& output) {
//std::unique_ptr<int[]> lhs_ipa = InParentArray();
//std::unique_ptr<int[]> rhs_ipa = rhs.InParentArray();

  int rc = CompareInner(rhs, cmp, output);

  _mol.transform_to_non_isotopic_form();
  rhs._mol.transform_to_non_isotopic_form();

  return rc;
}

int
DicedMolecule::CompareInner(DicedMolecule& rhs, const ComparisonConditions& cmp,
                IWString_and_File_Descriptor& output) {

  for (int i = 0; i < _fragment.number_elements(); ++i) {
    std::optional<int> maybe_rhs = rhs.Contains(_fragment[i]->usmi());
    if (! maybe_rhs) {
      continue;
    }
    // cerr << "Found match for " << _fragment[i]->usmi() << '\n';

    ProcessMatch(i, rhs, *maybe_rhs, cmp, output);

    if (_atype) {
      isotope_t next_isotope_to_assign = std::max<isotope_t>(_mol.natoms(), rhs._mol.natoms());
      isotope_t isave = next_isotope_to_assign;
      TryExpansion(rhs, cmp, next_isotope_to_assign);
      if (next_isotope_to_assign > isave) {
        ProcessMatch(i, rhs, *maybe_rhs, cmp, output);
      }
    }

    if (! cmp.allow_disconnected_matches) {
      return 1;
    }
  }

  return 0;
}

int
DicedMolecule::ProcessMatch(int lhs_frag_number, DicedMolecule& rhs,
                int rhs_frag_number,
                const ComparisonConditions& cmp,
                IWString_and_File_Descriptor& output) {
  const Fragment& lhs_frag = *_fragment[lhs_frag_number];
  const Fragment& rhs_frag = *rhs._fragment[rhs_frag_number];

  lhs_frag.SetIsotopes(_mol);
  rhs_frag.SetIsotopes(rhs._mol);

  static constexpr char kSep = ' ';

  output << _mol.smiles() << kSep << _mol.name() << kSep << "LHS" << kSep;
  lhs_frag.AtomsAndFraction(output);
  output << cmp.record_separator;
  output << rhs._mol.smiles() << kSep << rhs._mol.name() << kSep << "RHS" << kSep;
  rhs_frag.AtomsAndFraction(output);
  output << cmp.record_separator;

  return 1;
}

int
DicedMolecule::TryExpansion(DicedMolecule& rhs,
                const ComparisonConditions& cmp,
                isotope_t& next_isotope_to_assign) {
  int rc = 0;

  // Branch from each of the attachment points.

  const int matoms = _mol.natoms();
  for (int i = 0; i < matoms; ++i) {
    const isotope_t iso1 = _mol.isotope(i);
    if (iso1 == 0) {
      continue;
    }

    atom_number_t a2 = rhs._mol.atom_with_isotope(iso1);
    assert(a2 != kInvalidAtomNumber);
    // cerr << " lhs at " << i << " in system isotope " << _mol.isotope(i) << " ncon " << _mol.ncon(i) << '\n';

    for (const Bond * b : _mol[i]) {
      atom_number_t o = b->other(i);
      if (_mol.isotope(o) > 0) {
        continue;
      }

      atom_number_t rhs_atom = rhs.UnmatchedAtom(a2, b, _atype[o]);
      if (rhs_atom == kInvalidAtomNumber) {
        // cerr << "No matchon other side\n";
        continue;
      }
      // cerr << " rhs at " << o << " being added " << rhs._mol.smarts_equivalent_for_atom(rhs_atom) << '\n';

      _mol.set_isotope_no_perturb_canonical_ordering(o, next_isotope_to_assign);
      rhs._mol.set_isotope_no_perturb_canonical_ordering(rhs_atom, next_isotope_to_assign);
      ++next_isotope_to_assign;
      ++rc;
    }
  }

  if (rc == 0) {
    return 1;
  }

  return TryExpansion(rhs, cmp, next_isotope_to_assign);
}

// Look for an isotope 0 connection to `zatom`, connected via a
// bond of type `b` with the same atom type `atype`.
atom_number_t
DicedMolecule::UnmatchedAtom(atom_number_t zatom, const Bond* b1,
                             uint32_t atype) const {
  // cerr << "Looking for unmatched atom from " << zatom << " isotope " << _mol.isotope(zatom) << '\n';

  // cerr << " atom has " << _mol.ncon(zatom) << " connections\n";
  for (const Bond* b : _mol[zatom]) {
    // cerr << "same_bond_type " << b->same_bond_type(*b1) << '\n';
    if (! b->same_bond_type(*b1)) {
      continue;
    }
    atom_number_t o = b->other(zatom);
    // cerr << " atom " << o << " isotpe " << _mol.isotope(o) << '\n';
    if (_mol.isotope(o) > 0) {
      continue;
    }

    // cerr << "Atype " << _atype[o] << " cmp " << atype << '\n';
    if (_atype[o] != atype) {
      continue;
    }

    return o;
  }

  return kInvalidAtomNumber;
}

int
DicedMolecule::UpdateStats(int nmolecules, int ndx,
                absl::flat_hash_map<IWString, FragmentSummary>& frag_data) {
  for (const Fragment* frag : _fragment) {
    auto [iter, emplaced] = frag_data.try_emplace(frag->usmi(), std::move(FragmentSummary(nmolecules, ndx)));
    if (emplaced) {
      iter->second.set_natoms(frag->natoms());
    } else {
      iter->second.found_in_molecule(ndx);
    }
  }

  return 1;
}

class DicedMolecules {
  private:
    int _number_molecules;

    DicedMolecule* _mol;

  public:
    DicedMolecules();
    ~DicedMolecules();

    int Build(const Options& options, const char* fname);
    int Build(const Options& options, iwstring_data_source& input);

    int number_molecules() const {
      return _number_molecules;
    }

    DicedMolecule& operator[](int i) {
      return _mol[i];
    }
    
    void AssignAtomTypes(Atom_Typing_Specification& ats);

    const Fragment* GetFragment(const IWString& smi, const FragmentSummary& frag_summary) const;

    int DetermineMCS(const Options& options, IWString& smarts, IWString_and_File_Descriptor& output);
};

DicedMolecules::DicedMolecules() {
  _number_molecules = 0;
  _mol = nullptr;
}

DicedMolecules::~DicedMolecules() {
  if (_mol != nullptr) {
    delete [] _mol;
  }
}

int
DicedMolecules::Build(const Options& options, iwstring_data_source& input) {
  _number_molecules = input.records_remaining();
  if (_number_molecules == 0) {
    cerr << "DicedMolecules:Build: empty file\n";
    return 0;
  }

  _mol = new DicedMolecule[_number_molecules];

  const_IWSubstring buffer;
  for (int i = 0; i < _number_molecules; ++i) {
    input.next_record(buffer);
    dicer_data::DicedMolecule proto;
    google::protobuf::io::ArrayInputStream input(buffer.data(), buffer.length());
    if (! google::protobuf::TextFormat::Parse(&input, &proto)) {
      cerr << "DicedMolecule::Build:::invalid input\n";
      cerr << buffer << '\n';
      return 0;
    }
    if (! _mol[i].Build(options, proto)) {
      cerr << "DicedMolecules::Build:invalid data\n";
      cerr << proto.ShortDebugString() << '\n';
      return 0;
    }
  }

  return 1;
}

int
DicedMolecules::Build(const Options& options, const char* fname) {
  iwstring_data_source input(fname);
  if (! input.good()) {
    cerr << "DicedMolecule::Build:cannot open '" << fname << "'\n";
    return 0;
  }

  return Build(options, input);
}

void
DicedMolecules::AssignAtomTypes(Atom_Typing_Specification& ats) {
  for (int i = 0; i < _number_molecules; ++i) {
    _mol[i].AssignAtomTypes(ats);
  }
}

struct McsCandidate {
  public:
    int natoms;
    int nmolecules;
    IWString smi;
    Fragment* fragment;

  public:
    McsCandidate();
};

McsCandidate::McsCandidate() {
  natoms = 0;
  nmolecules = 0;
  fragment = nullptr;
}

const Fragment*
DicedMolecules::GetFragment(const IWString& smi, 
                            const FragmentSummary& frag_summary) const {
  for (int i = 0; i < _number_molecules; ++i) {
    if (! frag_summary.is_found_in_molecule(i)) {
      continue;
    }
    return _mol[i].FragmentForSmiles(smi);
  }

  return nullptr;
}

int
DicedMolecules::DetermineMCS(const Options& options,
                             IWString& smarts,
                             IWString_and_File_Descriptor& output) {
  if (_number_molecules == 0) {  [[unlikely]]
    return 0;
  }
  cerr << "Scanning " << _number_molecules << " molecules for fragments\n";

  int rc = 0;

  // Across all molecules read, a mapping from unique smiles of a
  // fragment to the molecules with that fragment.
  absl::flat_hash_map<IWString, FragmentSummary> frag_data;

  for (int i = 0; i < _number_molecules; ++i) {
    _mol[i].UpdateStats(_number_molecules, i, frag_data);
  }

  constexpr int kMaxNatoms = 100;
  std::unique_ptr<McsCandidate[]> candidates =
        std::make_unique<McsCandidate[]>(kMaxNatoms);

  for (const auto& [smi, data] : frag_data) {
    cerr << smi << " in " << data.molecules_with_fragment() << " molecules\n";
    int nat = data.natoms();
    if (data.molecules_with_fragment() > candidates[nat].nmolecules) {
      candidates[nat].nmolecules = data.molecules_with_fragment();
//    candidates[nat].fragment = _mol[i].FragmentForSmiles(smi);
      candidates[nat].smi = smi;
    }
  }

  if (options.verbose()) {
    for (int i = 1; i < kMaxNatoms; ++i) {
      const McsCandidate& c = candidates[i];
      if (c.nmolecules == 0) {
        continue;
      }
      cerr << c.smi << ' ' << i << " atoms " << c.nmolecules << " molecules\n";
    }
  }

  // For each atom count, we discern the most common MCS'
  int most_frequent = 0;
  int atoms_in_largest_mcs = 0;
  const FragmentSummary* frag = nullptr;
  const IWString* mcs_smiles = nullptr;
  for (const auto& [smi, data] : frag_data) {
    if (data.molecules_with_fragment() < most_frequent) {
      continue;
    }

    if (data.molecules_with_fragment() > most_frequent ||
        (data.molecules_with_fragment() == most_frequent &&
         data.natoms() > atoms_in_largest_mcs)) {
      most_frequent = data.molecules_with_fragment();
      mcs_smiles = &smi;
      atoms_in_largest_mcs = data.natoms();
      frag = &data;
    }
  }

  cerr << "Most common fragment " << *mcs_smiles << " found " << most_frequent << " times\n";

  // We need to find an example of the Fragment for the FragmentSummary found.

  // Loss of const OK.

  // Find the first molecule that contains this fragment.
  const Fragment* f = nullptr;
  for (int i = 0; i < _number_molecules; ++i) {
    if (! frag->is_found_in_molecule(i)) {
      continue;
    }

    f = _mol[i].FragmentForSmiles(*mcs_smiles);
    break;
  }

  if (f == nullptr) [[unlikely]] {
    cerr << "Did not find most common fragment " << *mcs_smiles << '\n';
    return 0;
  }

  const_cast<Fragment*>(f)->BuildSmarts(smarts);

  // Now write out all matching molecules.

  for (int i = 0; i < _number_molecules; ++i) {
    if (! frag->is_found_in_molecule(i)) {
      continue;
    }

    const Fragment* f = _mol[i].FragmentForSmiles(*mcs_smiles);
    Molecule& m = _mol[i].mol();
    m.unset_isotopes();
    f->SetIsotopes(m);
    output << m.smiles() << ' ' << m.name() << '\n';
    output.write_if_buffer_holds_more_than(4096);
  }

  return rc;
}

int
PerformPairwiseComparisons(Command_Line& cl,
                           DicedMolecules &diced,
                           IWString_and_File_Descriptor& output) {

  bool ok_compare_same_name = false;
  if (cl.option_present('w')) {
    ok_compare_same_name = true;
  }

  ComparisonConditions cmp;

  cmp.allow_disconnected_matches = 0;

  for (int i = 0; i < diced.number_molecules(); ++i) {
    DicedMolecule& m1 = diced[i];
    for (int j = i + 1; j < diced.number_molecules(); ++j) {
      if (i == j) {
        continue;
      }
      DicedMolecule& m2 = diced[j];

      if (ok_compare_same_name) {
      } else if (m1.name() == m2.name()) {
        continue;
      }
      m1.Compare(m2, cmp, output);
      output.write_if_buffer_holds_more_than(4096);
    }
  }

  output.flush();

  return 1;
}

int
PerformPairwiseComparisons(Command_Line& cl,
                           DicedMolecules &diced,
                           IWString& fname) {
  IWString_and_File_Descriptor output;
  if (! output.open(fname.null_terminated_chars())) {
    cerr << "PerformPairwiseComparisons:cannot open '" << fname << "'\n";
    return 0;
  }

  return PerformPairwiseComparisons(cl, diced, output);
}

int
Main(int argc, char** argv) {
  Command_Line cl(argc, argv, "vE:A:m:P:Y:");

  if (cl.unrecognised_options_encountered()) {
    cerr << "Unrecognised options encountered\n";
    Usage(1);
  }

  int verbose = cl.option_count('v');

  if (!process_standard_aromaticity_options(cl, verbose)) {
    Usage(5);
  }

  if (! process_elements(cl, verbose, 'E')) {
    cerr << "Cannot process elements\n";
    Usage(1);
  }

  Options options;
  if (! options.Initialise(cl)) {
    cerr << "Cannot initialise options\n";
    return 1;
  }

  if (cl.empty()) {
    cerr << "Insufficient arguments\n";
    Usage(1);
  }

#ifdef HUHAS
  if (cl.size() != 2) {
    cerr << "Must specify one or two files of dicer_data::DicedMolecule textproto inputs\n";
    Usage(1);
  }
#endif

  DicedMolecules diced1;

  if (! diced1.Build(options, cl[0])) {
    cerr << "Cannot read fragments from '" << cl[0] << "'\n";
    return 1;
  }

  if (verbose) {
    cerr << "Read " << diced1.number_molecules() << " molecules from " << cl[0] << '\n';
  }

  if (cl.option_present('P')) {
    IWString p = cl.string_value('P');

    Atom_Typing_Specification ats;
    if (! ats.build(p)) {
      cerr << "INvalid atom typing specification '" << p << "'\n";
      return 1;
    }

    diced1.AssignAtomTypes(ats);
  }

  if (cl.option_present('Y')) {
    IWString fname = cl.string_value('Y');
    PerformPairwiseComparisons(cl, diced1, fname);
  }

  IWString_and_File_Descriptor output(1);

  IWString smarts;
  diced1.DetermineMCS(options, smarts, output);

  output.flush();

  cerr << smarts << " MCS smarts\n";

  return 0;
}

}  // namespace dicer_mcs

int
main(int argc, char ** argv) {

  int rc = dicer_mcs::Main(argc, argv);

  return rc;
}
